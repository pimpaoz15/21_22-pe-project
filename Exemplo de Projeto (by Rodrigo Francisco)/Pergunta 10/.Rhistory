x = "Valores da distribuição da média", y = "Frequência relativa"))
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
library(ggplot2)
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_y_continuous(labels = scales::percent) + xlim(a, b) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa")) +
scale_y_continuous(expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic()
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
setwd("~/Trabalhos/Educação/21.22 IST/2º Semestre/PE/Projeto/Pergunta 6")
library(ggplot2)
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_y_continuous(labels = scales::percent) + xlim(a, b) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa")) +
scale_y_continuous(expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic()
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
library(ggplot2)
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa")) +
scale_y_continuous(labels = scales::percent) + xlim(a, b) +
scale_y_continuous(expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic()
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
library(ggplot2)
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa") +
scale_y_continuous(labels = scales::percent) + xlim(a, b) +
scale_y_continuous(expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic())
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa") +
scale_y_continuous(labels = scales::percent, expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic())
}
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa") +
scale_y_continuous(labels = scales::percent, expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic())
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa") +
scale_y_continuous(labels = scales::percent, expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic() +
theme(panel.grid.major.y = element_line(size = 0.4),
panel.grid.minor.y = element_line(size = 0.4)))
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1920, height = 1080, units = "px")
}
library(ggplot2)
grafico_com_n <- function(n, seed, samples, a, b) {
# Geração dos dados
set.seed(seed)
d <- replicate(samples, mean(runif(n, a, b)))
# Criação de uma distribuição normal com a mesma média e variância
X <- seq(from = a, to = b, length.out = samples)
f.X <- dnorm(X, mean = (a+b)/2, sd = sqrt(((b-a)^2)/(12*n)))
#Criação do data frame
dados <- data.frame(d, X, f.X)
# Desenho do gráfico com os dados
return(ggplot(dados, aes(d)) +
geom_histogram(aes(y = after_stat(count / sum(count)), fill = "Médias"),
binwidth = 0.2, color="white") +
geom_line(aes(x = X, y = f.X, color = "Normal")) +
scale_color_manual(values = c("Normal" = "firebrick2"), name = NULL) +
scale_fill_manual(values = c("Médias" = "deepskyblue"), name = NULL) +
labs(fill = "Médias", color = "Normal", subtitle = sprintf("n = %s", n),
title = "Distribuição de médias de distribuições uniformes",
x = "Valores da distribuição da média", y = "Frequência relativa") +
scale_y_continuous(labels = scales::percent, expand = c(0,0), limits = c(0, 3)) +
scale_x_continuous(expand = c(0,0), limits = c(a, b)) + theme_classic() +
theme(panel.grid.major.y = element_line(size = 0.4),
panel.grid.minor.y = element_line(size = 0.4)))
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1700, height = 1080, units = "px")
}
# Ciclo de geração dos gráficos para cada n
for(n in c(3, 24, 75)) {
plot <- grafico_com_n(n, seed=872, samples=560, a=9, b=13)
# Guarda o plot como imagem
ggsave(sprintf("Plot%s.png", n), plot, width = 1500, height = 1080, units = "px")
}
setwd("~/Trabalhos/Educação/21.22 IST/2º Semestre/PE/Projeto/Pergunta 9")
library(ggplot2)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0.1, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(0, 5000)) +
theme(panel.grid.major.y = element_line(size = 0.4),
panel.grid.minor.y = element_line(size = 0.4)) + theme_classic()
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0.1, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(ni, nf)) +
theme(panel.grid.major.y = element_line(size = 0.4),
panel.grid.minor.y = element_line(size = 0.4)) + theme_classic()
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0.1, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(ni, nf)) + theme_classic() +
theme(panel.grid.major.y = element_line(size = 0.4),
panel.grid.minor.y = element_line(size = 0.4))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0.1, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(ni, nf)) + theme_classic() +
theme(panel.grid.major = element_line(size = 0.4),
panel.grid.minor = element_line(size = 0.4))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0.1, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(0, 5100)) + theme_classic() +
theme(panel.grid.major = element_line(size = 0.4))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(0, 5100)) + theme_classic() +
theme(panel.grid.major = element_line(size = 0.4))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
grafico <- function(seed, m, ni, nf, nStep, lambda, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Desenho do gráfico
dados <- data.frame(ns, n)
plot <- ggplot(dados) + geom_line(aes(ns, n), color = "firebrick") +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
subtitle = sprintf("Média das amplitudes dos IC de %s amostras para cada n", m)) +
scale_y_continuous(expand = c(0,0), limits = c(0, 0.8)) +
scale_x_continuous(expand = c(0,0), limits = c(0, 5100)) + theme_classic() +
theme(panel.grid.major = element_line(size = 0.4),
panel.grid.minor = element_line(size = 0.4))
# Guarda o plot como imagem
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(seed=218, m=1450, ni=100, nf=5000, nStep=100, lambda=1.85, gama=0.96)
setwd("~/Trabalhos/Educação/21.22 IST/2º Semestre/PE/Projeto/Pergunta 10")
library(ggplot2)
grafico <- function(seed, m, ni, nf, nStep, lambda, erro, lambda_c, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Geração dos dados contaminados
set.seed(seed)
n_c <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
# erro% de amostras contaminadas + (1-erro)% de amostras puras
n_c[i] <- mean(replicate(m, k/mean(c(rexp(ns[i]*(1-erro) ,lambda),
rexp(ns[i]*erro ,lambda_c)))))
}
# Desenho do gráfico
dados <- data.frame(ns, n, n_c)
plot <- ggplot(dados) + geom_line(aes(ns, n, color = "Puras")) +
geom_line(aes(ns, n_c, color = "Contaminadas")) +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
color = "Amostras",
subtitle = "Média das amplitudes dos IC para amostras com e sem contaminação") +
scale_color_manual(values = c("Puras" = "deepskyblue", "Contaminadas" = "firebrick2"))
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(470, 800, 100, 2500, 100, 2.97, 0.15, 0.03, 0.98)
grafico <- function(seed, m, ni, nf, nStep, lambda, erro, lambda_c, gama) {
set.seed(seed)
ns <- seq(ni, nf, nStep)
a <- qnorm((1+gama)/2)  # inversa da distribuição normal para gama
# Geração dos dados
n <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
n[i] <- mean(replicate(m, k/mean(rexp(ns[i] ,lambda))))
}
# Geração dos dados contaminados
set.seed(seed)
n_c <- numeric(length(ns))
for(i in 1:length(ns)) {
k <- 2*(a/sqrt(ns[i]))
# erro% de amostras contaminadas + (1-erro)% de amostras puras
n_c[i] <- mean(replicate(m, k/mean(c(rexp(ns[i]*(1-erro) ,lambda),
rexp(ns[i]*erro ,lambda_c)))))
}
# Desenho do gráfico
dados <- data.frame(ns, n, n_c)
plot <- ggplot(dados) + geom_line(aes(ns, n, color = "Puras")) +
geom_line(aes(ns, n_c, color = "Contaminadas")) +
labs(x = "n", y = "MA(n)", title = "Amplitudes dos Intervalos de Confiança",
color = "Amostras",
subtitle = "Média das amplitudes dos IC para amostras com e sem contaminação") +
scale_color_manual(values = c("Puras" = "deepskyblue", "Contaminadas" = "firebrick2")) +
scale_y_continuous(expand = c(0,0), limits = c(0, 1.5)) +
scale_x_continuous(expand = c(0,0), limits = c(0, 2500)) + theme_classic() +
theme(panel.grid.major = element_line(size = 0.4),
panel.grid.minor = element_line(size = 0.4))
ggsave("Plot.png", plot, width = 1920, height = 1080, units = "px")
return(plot)
}
# Chama a função com os valores do enunciado
grafico(470, 800, 100, 2500, 100, 2.97, 0.15, 0.03, 0.98)
